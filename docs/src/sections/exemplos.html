<section>
  <h2>üíº Exemplos Pr√°ticos</h2>

  <h3>Autentica√ß√£o JWT</h3>
  <p>
    Implementa√ß√£o completa de autentica√ß√£o com JWT, incluindo login, logout e
    refresh de token:
  </p>
  <pre><code>import { createApiClient } from 'ease-fetch';

const api = createApiClient({
  baseURL: 'https://api.example.com'
});

// Adiciona token automaticamente em todas requisi√ß√µes
api.addRequestInterceptor((endpoint, options) => {
  // Endpoints p√∫blicos que n√£o precisam de autentica√ß√£o
  const publicEndpoints = ['/auth/login', '/auth/register'];
  if (publicEndpoints.includes(endpoint)) {
    return [endpoint, options];
  }

  const token = localStorage.getItem('auth_token');
  if (token) {
    options.headers = {
      ...options.headers,
      Authorization: `Bearer ${token}`
    };
  }
  
  return [endpoint, options];
});

// Trata erro 401 (token expirado)
api.addResponseErrorInterceptor(async (error) => {
  if (error.status === 401) {
    const refreshToken = localStorage.getItem('refresh_token');
    
    if (refreshToken) {
      try {
        // Tenta renovar o token
        const response = await fetch('https://api.example.com/auth/refresh', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ refreshToken })
        });
        
        if (response.ok) {
          const { token } = await response.json();
          localStorage.setItem('auth_token', token);
          // Token renovado, usu√°rio pode tentar novamente
          window.location.reload();
          return;
        }
      } catch (refreshError) {
        console.error('Falha ao renovar token:', refreshError);
      }
    }
    
    // N√£o conseguiu renovar, redireciona para login
    localStorage.removeItem('auth_token');
    localStorage.removeItem('refresh_token');
    window.location.href = '/login';
  }
  
  throw error;
});

// Servi√ßo de autentica√ß√£o
export const AuthService = {
  async login(email, password) {
    const response = await api.post('/auth/login', { email, password });
    localStorage.setItem('auth_token', response.token);
    localStorage.setItem('refresh_token', response.refreshToken);
    return response.user;
  },

  async logout() {
    await api.post('/auth/logout');
    localStorage.removeItem('auth_token');
    localStorage.removeItem('refresh_token');
    window.location.href = '/login';
  },

  async getCurrentUser() {
    return api.get('/auth/me');
  }
};

// Uso
try {
  const user = await AuthService.login('user@example.com', 'senha123');
  console.log('Login bem-sucedido:', user);
} catch (error) {
  console.error('Erro no login:', error.message);
}</code></pre>

  <h3>Pagina√ß√£o de Dados</h3>
  <p>Carregamento eficiente de grandes conjuntos de dados com pagina√ß√£o:</p>
  <pre><code>class PaginatedList {
  constructor(api, endpoint) {
    this.api = api;
    this.endpoint = endpoint;
    this.currentPage = 1;
    this.items = [];
    this.hasMore = true;
  }

  async loadPage(page = this.currentPage) {
    try {
      const response = await this.api.get(`${this.endpoint}?page=${page}&limit=20`);
      
      this.items = [...this.items, ...response.data];
      this.currentPage = page;
      this.hasMore = response.hasNextPage;
      
      return response.data;
    } catch (error) {
      console.error('Erro ao carregar p√°gina:', error);
      throw error;
    }
  }

  async loadNext() {
    if (!this.hasMore) {
      console.log('N√£o h√° mais itens para carregar');
      return [];
    }
    return this.loadPage(this.currentPage + 1);
  }

  reset() {
    this.currentPage = 1;
    this.items = [];
    this.hasMore = true;
  }
}

// Uso
const api = createApiClient({ baseURL: 'https://api.example.com' });
const userList = new PaginatedList(api, '/users');

// Carrega primeira p√°gina
const firstPage = await userList.loadPage();
console.log('Primeira p√°gina:', firstPage);

// Carrega pr√≥xima p√°gina
const secondPage = await userList.loadNext();
console.log('Segunda p√°gina:', secondPage);

// Infinite scroll
window.addEventListener('scroll', async () => {
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
    if (userList.hasMore) {
      await userList.loadNext();
      renderUsers(userList.items);
    }
  }
});</code></pre>

  <h3>Busca com Debounce</h3>
  <p>
    Otimize requisi√ß√µes de busca evitando chamadas excessivas enquanto o usu√°rio
    digita:
  </p>
  <pre><code>class SearchService {
  constructor(api, endpoint, delay = 300) {
    this.api = api;
    this.endpoint = endpoint;
    this.delay = delay;
    this.timeoutId = null;
    this.controller = null;
  }

  async search(query) {
    // Cancela busca anterior se ainda estiver pendente
    if (this.controller) {
      this.controller.abort();
    }

    // Limpa timeout anterior
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }

    // Se query vazia, retorna vazio imediatamente
    if (!query.trim()) {
      return [];
    }

    // Cria nova promise com debounce
    return new Promise((resolve, reject) => {
      this.timeoutId = setTimeout(async () => {
        try {
          this.controller = new AbortController();
          
          const results = await this.api.get(
            `${this.endpoint}?q=${encodeURIComponent(query)}`,
            { signal: this.controller.signal }
          );
          
          resolve(results);
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Busca anterior cancelada');
          } else {
            reject(error);
          }
        }
      }, this.delay);
    });
  }
}

// Uso
const api = createApiClient({ baseURL: 'https://api.example.com' });
const searchService = new SearchService(api, '/users/search', 300);

const searchInput = document.getElementById('search');
const resultsDiv = document.getElementById('results');

searchInput.addEventListener('input', async (e) => {
  const query = e.target.value;
  
  try {
    resultsDiv.innerHTML = '<p>Buscando...</p>';
    const results = await searchService.search(query);
    
    if (results.length === 0) {
      resultsDiv.innerHTML = '<p>Nenhum resultado encontrado</p>';
    } else {
      resultsDiv.innerHTML = results
        .map(user => `<div>${user.name} - ${user.email}</div>`)
        .join('');
    }
  } catch (error) {
    if (error.name !== 'AbortError') {
      resultsDiv.innerHTML = `<p>Erro: ${error.message}</p>`;
    }
  }
});</code></pre>

  <h3>Cache de Requisi√ß√µes</h3>
  <p>Implemente cache simples para reduzir requisi√ß√µes redundantes:</p>
  <pre><code>class CachedApiClient {
  constructor(api, ttlMs = 60000) {
    this.api = api;
    this.ttlMs = ttlMs;
    this.cache = new Map();
  }

  getCacheKey(endpoint, options) {
    return `${options.method || 'GET'}:${endpoint}:${JSON.stringify(options.body || {})}`;
  }

  isExpired(timestamp) {
    return Date.now() - timestamp > this.ttlMs;
  }

  async get(endpoint, options = {}) {
    const cacheKey = this.getCacheKey(endpoint, options);
    const cached = this.cache.get(cacheKey);

    // Retorna do cache se v√°lido
    if (cached && !this.isExpired(cached.timestamp)) {
      console.log('Cache HIT:', cacheKey);
      return cached.data;
    }

    // Busca da API
    console.log('Cache MISS:', cacheKey);
    const data = await this.api.get(endpoint, options);

    // Armazena no cache
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });

    return data;
  }

  invalidate(endpoint) {
    // Invalida todas as entradas que contenham o endpoint
    for (const [key] of this.cache) {
      if (key.includes(endpoint)) {
        this.cache.delete(key);
      }
    }
  }

  clear() {
    this.cache.clear();
  }
}

// Uso
const api = createApiClient({ baseURL: 'https://api.example.com' });
const cachedApi = new CachedApiClient(api, 60000); // Cache de 1 minuto

// Primeira chamada - busca da API
const users1 = await cachedApi.get('/users'); // Cache MISS

// Segunda chamada - retorna do cache
const users2 = await cachedApi.get('/users'); // Cache HIT

// Ap√≥s criar usu√°rio, invalida cache
await api.post('/users', newUser);
cachedApi.invalidate('/users');

// Pr√≥xima chamada busca da API novamente
const users3 = await cachedApi.get('/users'); // Cache MISS</code></pre>

  <h3>Requisi√ß√µes em Lote (Batch)</h3>
  <p>Agrupe m√∫ltiplas requisi√ß√µes para reduzir overhead de rede:</p>
  <pre><code>class BatchRequestQueue {
  constructor(api, maxBatchSize = 10, delayMs = 50) {
    this.api = api;
    this.maxBatchSize = maxBatchSize;
    this.delayMs = delayMs;
    this.queue = [];
    this.timeoutId = null;
  }

  async request(endpoint, options = {}) {
    return new Promise((resolve, reject) => {
      // Adiciona requisi√ß√£o √† fila
      this.queue.push({ endpoint, options, resolve, reject });

      // Limpa timeout anterior
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
      }

      // Processa quando atingir tamanho m√°ximo ou ap√≥s delay
      if (this.queue.length >= this.maxBatchSize) {
        this.flush();
      } else {
        this.timeoutId = setTimeout(() => this.flush(), this.delayMs);
      }
    });
  }

  async flush() {
    if (this.queue.length === 0) return;

    const batch = this.queue.splice(0, this.maxBatchSize);
    
    try {
      // Envia todas requisi√ß√µes em paralelo
      const responses = await Promise.allSettled(
        batch.map(({ endpoint, options }) => 
          this.api.request(endpoint, options)
        )
      );

      // Resolve/rejeita cada promise individualmente
      responses.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          batch[index].resolve(result.value);
        } else {
          batch[index].reject(result.reason);
        }
      });
    } catch (error) {
      // Em caso de erro geral, rejeita todas
      batch.forEach(({ reject }) => reject(error));
    }

    // Se ainda h√° itens na fila, processa pr√≥ximo lote
    if (this.queue.length > 0) {
      setTimeout(() => this.flush(), 0);
    }
  }
}

// Uso
const api = createApiClient({ baseURL: 'https://api.example.com' });
const batchQueue = new BatchRequestQueue(api);

// M√∫ltiplas requisi√ß√µes s√£o agrupadas automaticamente
const promises = [
  batchQueue.request('/users/1'),
  batchQueue.request('/users/2'),
  batchQueue.request('/users/3'),
  batchQueue.request('/posts/1'),
  batchQueue.request('/posts/2')
];

// Aguarda todas as respostas
const results = await Promise.all(promises);
console.log('Resultados:', results);</code></pre>

  <h3>Tratamento de Rate Limit</h3>
  <p>Respeite limites de taxa da API com retry autom√°tico:</p>
  <pre><code>class RateLimitHandler {
  constructor(api) {
    this.api = api;
    this.setupInterceptor();
  }

  setupInterceptor() {
    this.api.addResponseErrorInterceptor(async (error) => {
      if (error.status === 429) {
        // Extrai tempo de espera do header
        const retryAfter = error.data?.retryAfter || 60;
        
        console.warn(`Rate limit atingido. Aguardando ${retryAfter}s...`);
        
        // Aguarda o tempo especificado
        await new Promise(resolve => 
          setTimeout(resolve, retryAfter * 1000)
        );

        // Retorna undefined para sinalizar que deve retentar
        // (implementa√ß√£o depende de como voc√™ quer lidar com isso)
        throw new Error('Rate limit - retry necess√°rio');
      }
      
      throw error;
    });
  }
}

// Uso
const api = createApiClient({ baseURL: 'https://api.example.com' });
new RateLimitHandler(api);

// Agora todas requisi√ß√µes respeitam rate limit automaticamente
try {
  const data = await api.get('/users');
} catch (error) {
  if (error.message.includes('Rate limit')) {
    console.log('Retentar ap√≥s aguardar...');
  }
}</code></pre>
</section>
