<section>
  <h2>üìö Conceitos Fundamentais</h2>

  <h3>Inst√¢ncia do Cliente</h3>
  <p>
    O Ease-Fetch utiliza o padr√£o de design <strong>Factory</strong>. Voc√™ cria
    uma inst√¢ncia do cliente configurada com suas prefer√™ncias e a reutiliza em
    toda aplica√ß√£o:
  </p>
  <pre><code>import { createApiClient } from 'ease-fetch';

// Crie uma inst√¢ncia configurada
const api = createApiClient({
  baseURL: 'https://api.example.com',
  timeoutMs: 10000,
  maxRetries: 3
});

// Reutilize em diferentes partes da aplica√ß√£o
export default api;</code></pre>

  <h3>Base URL</h3>
  <p>
    A <code>baseURL</code> √© prefixada automaticamente em todos os endpoints.
    Isso centraliza a configura√ß√£o e facilita a migra√ß√£o entre ambientes
    (desenvolvimento, staging, produ√ß√£o):
  </p>
  <pre><code>const api = createApiClient({
  baseURL: 'https://api.example.com'
});

// Requisi√ß√£o para: https://api.example.com/users
await api.get('/users');

// Requisi√ß√£o para: https://api.example.com/posts/123
await api.get('/posts/123');</code></pre>

  <div class="card">
    <p>
      <strong>üí° Dica:</strong> Use vari√°veis de ambiente para configurar
      diferentes URLs por ambiente:
    </p>
    <pre><code>const api = createApiClient({
  baseURL: process.env.API_URL || 'http://localhost:3000'
});</code></pre>
  </div>

  <h3>M√©todos HTTP</h3>
  <p>
    O Ease-Fetch oferece m√©todos para cada verbo HTTP, com assinaturas
    consistentes e intuitivas:
  </p>

  <div class="api-list">
    <div class="api-item">
      <h4>GET - Buscar Dados</h4>
      <p>Usado para recuperar recursos sem modificar o servidor.</p>
      <pre><code>// Buscar lista
const users = await api.get('/users');

// Buscar recurso espec√≠fico
const user = await api.get('/users/123');

// Com query parameters
const filtered = await api.get('/users?role=admin&active=true');</code></pre>
    </div>

    <div class="api-item">
      <h4>POST - Criar Recursos</h4>
      <p>Usado para criar novos recursos no servidor.</p>
      <pre><code>const newUser = await api.post('/users', {
  name: 'Jo√£o Silva',
  email: 'joao@example.com',
  role: 'user'
});</code></pre>
    </div>

    <div class="api-item">
      <h4>PUT - Substituir Completamente</h4>
      <p>
        Substitui todo o recurso com os novos dados. Todos os campos devem ser
        enviados.
      </p>
      <pre><code>// Substitui TODOS os dados do usu√°rio 123
const updated = await api.put('/users/123', {
  name: 'Jo√£o Santos',
  email: 'joao.santos@example.com',
  role: 'admin',
  active: true
  // Todos os campos necess√°rios
});</code></pre>
    </div>

    <div class="api-item">
      <h4>PATCH - Atualizar Parcialmente</h4>
      <p>
        Atualiza apenas os campos especificados, mantendo os demais inalterados.
      </p>
      <pre><code>// Atualiza apenas o email
const patched = await api.patch('/users/123', {
  email: 'novo.email@example.com'
  // Outros campos permanecem iguais
});</code></pre>
    </div>

    <div class="api-item">
      <h4>DELETE - Remover Recursos</h4>
      <p>Remove um recurso do servidor.</p>
      <pre><code>// Retorna vazio (status 204) ou confirma√ß√£o
await api.delete('/users/123');</code></pre>
    </div>
  </div>

  <h3>Idempot√™ncia e Retry</h3>
  <p>
    <strong>M√©todos idempotentes</strong> (GET, PUT, DELETE) podem ser
    executados m√∫ltiplas vezes sem causar efeitos colaterais diferentes. O
    Ease-Fetch aproveita isso para retry autom√°tico:
  </p>

  <div class="card">
    <pre><code>// ‚úÖ GET, PUT, DELETE - Retry autom√°tico em erro 5xx
await api.get('/users');     // At√© 3 tentativas
await api.put('/users/1');   // At√© 3 tentativas
await api.delete('/users/1'); // At√© 3 tentativas

// ‚ùå POST, PATCH - SEM retry (n√£o s√£o idempotentes)
await api.post('/users');    // Apenas 1 tentativa
await api.patch('/users/1'); // Apenas 1 tentativa</code></pre>
    <p>
      <strong>Por qu√™?</strong> POST pode criar recursos duplicados se executado
      duas vezes. PATCH pode aplicar a mesma modifica√ß√£o m√∫ltiplas vezes com
      resultados imprevis√≠veis.
    </p>
  </div>

  <h3>Headers e Content-Type</h3>
  <p>
    O Ease-Fetch gerencia headers automaticamente, mas voc√™ pode customiz√°-los
    quando necess√°rio:
  </p>

  <div class="api-item">
    <h4>Headers Autom√°ticos</h4>
    <pre><code>// JSON - Content-Type: application/json (autom√°tico)
await api.post('/users', { name: 'Jo√£o' });

// FormData - Content-Type: multipart/form-data (autom√°tico)
const form = new FormData();
form.append('file', file);
await api.post('/upload', form);</code></pre>
  </div>

  <div class="api-item">
    <h4>Headers Customizados</h4>
    <pre><code>// Por requisi√ß√£o
await api.get('/users', {
  headers: {
    'X-Custom-Header': 'valor',
    'Accept-Language': 'pt-BR'
  }
});

// Globalmente via interceptor (recomendado)
api.addRequestInterceptor((endpoint, options) => {
  options.headers = {
    ...options.headers,
    'X-API-Version': '2.0'
  };
  return [endpoint, options];
});</code></pre>
  </div>

  <h3>Respostas HTTP</h3>
  <p>
    O Ease-Fetch processa automaticamente as respostas baseado no Content-Type:
  </p>

  <div class="api-list">
    <div class="api-item">
      <h4>JSON (Padr√£o)</h4>
      <pre><code>// Response: { "id": 1, "name": "Jo√£o" }
const user = await api.get('/users/1');
console.log(user.name); // "Jo√£o"</code></pre>
    </div>

    <div class="api-item">
      <h4>Texto Puro</h4>
      <pre><code>// Response: "Hello World"
const text = await api.get('/message');
console.log(text); // "Hello World"</code></pre>
    </div>

    <div class="api-item">
      <h4>Status 204 (No Content)</h4>
      <pre><code>// DELETE geralmente retorna 204 sem corpo
const result = await api.delete('/users/1');
console.log(result); // null</code></pre>
    </div>
  </div>

  <h3>Configura√ß√µes por Requisi√ß√£o</h3>
  <p>
    Voc√™ pode sobrescrever configura√ß√µes globais em requisi√ß√µes espec√≠ficas:
  </p>
  <pre><code>const api = createApiClient({
  timeoutMs: 5000  // Padr√£o: 5 segundos
});

// Sobrescreve apenas para essa requisi√ß√£o
await api.get('/slow-report', {
  timeoutMs: 60000  // 60 segundos apenas aqui
});

// Outras requisi√ß√µes continuam com 5 segundos
await api.get('/users'); // 5 segundos</code></pre>
</section>
