<section id="api">
  <h2>üìñ Refer√™ncia da API</h2>

  <h3>createApiClient(options?)</h3>
  <p>
    Cria e retorna uma nova inst√¢ncia do cliente HTTP configurada com as op√ß√µes
    fornecidas.
  </p>

  <h4>Par√¢metros</h4>
  <div class="api-list">
    <div class="api-item">
      <code>baseURL?: string</code>
      <p>
        URL base que ser√° prefixada automaticamente em todos os endpoints. √ötil
        para centralizar a configura√ß√£o e evitar repeti√ß√£o.
      </p>
      <pre><code>// Exemplo
const api = createApiClient({
  baseURL: 'https://api.example.com'
});

// Requisi√ß√£o para: https://api.example.com/users
await api.get('/users');</code></pre>
    </div>

    <div class="api-item">
      <code>timeoutMs?: number</code>
      <p>
        Tempo m√°ximo em milissegundos que uma requisi√ß√£o pode levar antes de ser
        cancelada automaticamente. Padr√£o:
        <strong>10000ms (10 segundos)</strong>.
      </p>
      <pre><code>// Timeout global de 5 segundos
const api = createApiClient({
  timeoutMs: 5000
});

// Sobrescreve apenas para essa requisi√ß√£o
await api.get('/slow-endpoint', {
  timeoutMs: 30000 // 30 segundos
});</code></pre>
    </div>

    <div class="api-item">
      <code>maxRetries?: number</code>
      <p>
        N√∫mero m√°ximo de tentativas autom√°ticas para requisi√ß√µes que falharem
        com erros de servidor (5xx). Apenas m√©todos idempotentes (GET, PUT,
        DELETE) s√£o retentados. Padr√£o: <strong>3</strong>.
      </p>
      <pre><code>const api = createApiClient({
  maxRetries: 5 // At√© 5 tentativas em caso de erro 5xx
});</code></pre>
      <p>
        O tempo entre tentativas usa <strong>backoff exponencial</strong>:
        300ms, 600ms, 1200ms...
      </p>
    </div>

    <div class="api-item">
      <code>fetchImpl?: typeof fetch</code>
      <p>
        Implementa√ß√£o customizada da fun√ß√£o fetch. √ötil para ambientes Node.js
        ou para testes.
      </p>
      <pre><code>import nodeFetch from 'node-fetch';

const api = createApiClient({
  fetchImpl: nodeFetch
});</code></pre>
    </div>

    <div class="api-item">
      <code>logger?: { debug?, error? }</code>
      <p>
        Objeto com fun√ß√µes de logging para debug e erro. √ötil para
        desenvolvimento e monitoramento.
      </p>
      <pre><code>const api = createApiClient({
  logger: {
    debug: (...args) => console.log('[DEBUG]', ...args),
    error: (...args) => console.error('[ERROR]', ...args)
  }
});</code></pre>
    </div>
  </div>

  <h3>M√©todos HTTP</h3>

  <div class="api-list">
    <div class="api-item">
      <h4>get&lt;T&gt;(endpoint, options?): Promise&lt;T&gt;</h4>
      <p>Executa uma requisi√ß√£o GET para buscar dados.</p>
      <pre><code>// Buscar todos os usu√°rios
const users = await api.get('/users');

// Com tipo espec√≠fico
interface User { id: number; name: string; }
const user = await api.get&lt;User&gt;('/users/123');

// Com op√ß√µes
const data = await api.get('/users', {
  headers: { 'Accept-Language': 'pt-BR' },
  timeoutMs: 5000
});</code></pre>
    </div>

    <div class="api-item">
      <h4>post&lt;T&gt;(endpoint, body?, options?): Promise&lt;T&gt;</h4>
      <p>Executa uma requisi√ß√£o POST para criar recursos.</p>
      <pre><code>// JSON autom√°tico
const newUser = await api.post('/users', {
  name: 'Jo√£o Silva',
  email: 'joao@example.com'
});

// FormData autom√°tico
const formData = new FormData();
formData.append('file', file);
const result = await api.post('/upload', formData);

// Blob
await api.post('/image', blobData);</code></pre>
    </div>

    <div class="api-item">
      <h4>put&lt;T&gt;(endpoint, body?, options?): Promise&lt;T&gt;</h4>
      <p>
        Executa uma requisi√ß√£o PUT para substituir completamente um recurso.
      </p>
      <pre><code>const updated = await api.put('/users/123', {
  name: 'Jo√£o Santos',
  email: 'joao.santos@example.com',
  role: 'admin'
});</code></pre>
    </div>

    <div class="api-item">
      <h4>patch&lt;T&gt;(endpoint, body?, options?): Promise&lt;T&gt;</h4>
      <p>
        Executa uma requisi√ß√£o PATCH para atualizar parcialmente um recurso.
      </p>
      <pre><code>// Atualiza apenas o email
const patched = await api.patch('/users/123', {
  email: 'novo@example.com'
});</code></pre>
    </div>

    <div class="api-item">
      <h4>delete&lt;T&gt;(endpoint, options?): Promise&lt;T&gt;</h4>
      <p>Executa uma requisi√ß√£o DELETE para remover um recurso.</p>
      <pre><code>await api.delete('/users/123');</code></pre>
    </div>

    <div class="api-item">
      <h4>request&lt;T&gt;(endpoint, options): Promise&lt;T&gt;</h4>
      <p>
        M√©todo gen√©rico que permite especificar qualquer verbo HTTP manualmente.
      </p>
      <pre><code>const data = await api.request('/users', {
  method: 'OPTIONS',
  headers: { 'Custom-Header': 'value' }
});</code></pre>
    </div>
  </div>

  <h3>RequestOptions</h3>
  <p>Objeto de configura√ß√£o aceito por todos os m√©todos HTTP:</p>

  <div class="api-list">
    <div class="api-item">
      <code>method?: string</code>
      <p>
        Verbo HTTP (GET, POST, PUT, PATCH, DELETE, etc). Definido
        automaticamente pelos m√©todos espec√≠ficos.
      </p>
    </div>

    <div class="api-item">
      <code>body?: BodyInit | null</code>
      <p>
        Corpo da requisi√ß√£o. Pode ser: JSON object, FormData, Blob, string,
        ArrayBuffer, etc.
      </p>
    </div>

    <div class="api-item">
      <code>headers?: HeadersObj | Headers</code>
      <p>Headers HTTP customizados. Mesclados com headers padr√£o.</p>
      <pre><code>await api.get('/users', {
  headers: {
    'Accept-Language': 'pt-BR',
    'X-Custom-Header': 'valor'
  }
});</code></pre>
    </div>

    <div class="api-item">
      <code>timeoutMs?: number</code>
      <p>Sobrescreve o timeout global apenas para essa requisi√ß√£o.</p>
    </div>

    <div class="api-item">
      <code>signal?: AbortSignal</code>
      <p>Signal do AbortController para cancelamento manual.</p>
      <pre><code>const controller = new AbortController();
const promise = api.get('/users', { signal: controller.signal });

// Cancela ap√≥s 5 segundos
setTimeout(() => controller.abort(), 5000);</code></pre>
    </div>

    <div class="api-item">
      <code>credentials?: RequestCredentials</code>
      <p>
        Controla envio de cookies. Valores: 'omit', 'same-origin', 'include'.
      </p>
    </div>

    <div class="api-item">
      <code>mode?: RequestMode</code>
      <p>Modo CORS. Valores: 'cors', 'no-cors', 'same-origin'.</p>
    </div>
  </div>

  <h3>Interceptors</h3>

  <div class="api-list">
    <div class="api-item">
      <h4>addRequestInterceptor(interceptor)</h4>
      <p>
        Adiciona uma fun√ß√£o que ser√° executada antes de cada requisi√ß√£o ser
        enviada. Permite modificar endpoint e op√ß√µes.
      </p>
      <pre><code>api.addRequestInterceptor((endpoint, options) => {
  // Modifica options
  options.headers = {
    ...options.headers,
    Authorization: `Bearer ${getToken()}`
  };
  
  // Retorna [endpoint, options] modificados
  return [endpoint, options];
});</code></pre>
      <p><strong>Ass√≠ncrono:</strong> Pode retornar Promise ou valor direto.</p>
    </div>

    <div class="api-item">
      <h4>addResponseInterceptor(interceptor)</h4>
      <p>
        Adiciona uma fun√ß√£o que ser√° executada ap√≥s receber a resposta, mas
        antes do parsing. Permite modificar ou inspecionar a Response.
      </p>
      <pre><code>api.addResponseInterceptor((response) => {
  console.log('Status:', response.status);
  console.log('Headers:', response.headers);
  
  // Retorna response (modificado ou n√£o)
  return response;
});</code></pre>
    </div>

    <div class="api-item">
      <h4>addResponseErrorInterceptor(interceptor)</h4>
      <p>
        Adiciona uma fun√ß√£o que ser√° executada quando ocorrer um erro. Permite
        tratamento global, logging ou retry manual.
      </p>
      <pre><code>api.addResponseErrorInterceptor((error) => {
  // Tratamento global
  if (error.status === 401) {
    redirectToLogin();
  }
  
  // Re-lan√ßa o erro para tratamento local
  throw error;
});</code></pre>
      <p>
        <strong>Importante:</strong> Deve sempre lan√ßar o erro novamente (throw)
        ao final.
      </p>
    </div>
  </div>

  <h3>ApiError</h3>
  <p>Objeto de erro lan√ßado quando uma requisi√ß√£o falha:</p>

  <div class="api-list">
    <div class="api-item">
      <code>message: string</code>
      <p>
        Descri√ß√£o textual do erro (ex: "Not Found", "Internal Server Error").
      </p>
    </div>

    <div class="api-item">
      <code>status?: number</code>
      <p>C√≥digo de status HTTP (ex: 404, 500, 401).</p>
    </div>

    <div class="api-item">
      <code>data?: unknown</code>
      <p>
        Corpo da resposta de erro enviado pelo servidor, se dispon√≠vel. Pode
        conter detalhes adicionais.
      </p>
    </div>
  </div>

  <pre><code>try {
  await api.get('/users/999');
} catch (error) {
  console.log(error.message);  // "Not Found"
  console.log(error.status);   // 404
  console.log(error.data);     // { detail: "User not found" }
}</code></pre>

  <h3>TypeScript</h3>
  <p>O Ease-Fetch √© constru√≠do em TypeScript com suporte completo a tipos:</p>

  <div class="api-item">
    <h4>Tipos de Resposta Gen√©ricos</h4>
    <pre><code>interface User {
  id: number;
  name: string;
  email: string;
  createdAt: string;
}

interface ApiResponse&lt;T&gt; {
  data: T;
  meta: {
    page: number;
    total: number;
  };
}

// TypeScript infere o tipo corretamente
const response = await api.get&lt;ApiResponse&lt;User[]&gt;&gt;('/users');
response.data[0].email; // ‚úÖ Type-safe
response.meta.page;     // ‚úÖ Type-safe</code></pre>
  </div>

  <div class="api-item">
    <h4>Tipos Exportados</h4>
    <pre><code>import type {
  ApiClient,
  ApiClientOptions,
  RequestOptions,
  ApiError,
  RequestInterceptor,
  ResponseInterceptor,
  ResponseErrorInterceptor,
  HeadersObj
} from 'ease-fetch';</code></pre>
  </div>
</section>
