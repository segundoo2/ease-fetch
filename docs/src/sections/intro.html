<section>
  <h2>üéØ O que √© Ease-Fetch?</h2>
  <p>
    Ease-Fetch √© um wrapper moderno e type-safe para requisi√ß√µes HTTP que
    elimina a complexidade do fetch nativo. Constru√≠do em TypeScript, oferece
    uma API fluente e previs√≠vel para consumo de APIs REST.
  </p>

  <h3>Por que Ease-Fetch?</h3>
  <div class="api-list">
    <div class="api-item">
      <h4>üîÑ Retry Autom√°tico com Backoff Exponencial</h4>
      <p>
        Requisi√ß√µes idempotentes (GET, PUT, DELETE) s√£o automaticamente
        reexecutadas em caso de falhas de servidor (5xx). O tempo de espera
        entre tentativas aumenta exponencialmente: 300ms, 600ms, 1200ms,
        reduzindo a carga no servidor.
      </p>
      <pre><code>// Configura at√© 3 tentativas autom√°ticas
const api = createApiClient({
  maxRetries: 3
});

// Se o servidor retornar 500, a lib tenta automaticamente
await api.get('/users'); // Retry autom√°tico em caso de erro 5xx</code></pre>
    </div>

    <div class="api-item">
      <h4>‚ö° Sistema de Interceptors Completo</h4>
      <p>
        Intercepte e modifique requisi√ß√µes antes de envi√°-las ou respostas antes
        de process√°-las. Perfeito para autentica√ß√£o, logging, transforma√ß√£o de
        dados e tratamento global de erros.
      </p>
      <pre><code>// Request Interceptor - adiciona token em todas requisi√ß√µes
api.addRequestInterceptor((endpoint, options) => {
  const token = getAuthToken();
  options.headers = {
    ...options.headers,
    Authorization: `Bearer ${token}`
  };
  return [endpoint, options];
});

// Response Interceptor - transforma todas respostas
api.addResponseInterceptor((response) => {
  console.log('Status:', response.status);
  return response;
});

// Error Interceptor - tratamento global de erros
api.addResponseErrorInterceptor((error) => {
  if (error.status === 401) {
    redirectToLogin();
  }
  throw error;
});</code></pre>
    </div>

    <div class="api-item">
      <h4>‚è±Ô∏è Timeout Configur√°vel e Gerenciamento de AbortController</h4>
      <p>
        Protege sua aplica√ß√£o de requisi√ß√µes travadas. Cada requisi√ß√£o tem um
        timeout padr√£o de 10 segundos, mas voc√™ pode configurar globalmente ou
        por requisi√ß√£o.
      </p>
      <pre><code>// Timeout global de 5 segundos
const api = createApiClient({
  timeoutMs: 5000
});

// Override para requisi√ß√£o espec√≠fica
await api.get('/slow-endpoint', {
  timeoutMs: 30000 // 30 segundos para esse endpoint
});</code></pre>
    </div>

    <div class="api-item">
      <h4>üì¶ Detec√ß√£o Autom√°tica de Content-Type</h4>
      <p>
        JSON, FormData, Blob - a biblioteca detecta e envia corretamente sem
        configura√ß√£o manual de headers.
      </p>
      <pre><code>// JSON autom√°tico
await api.post('/users', { name: 'John' });

// FormData autom√°tico (sem definir Content-Type)
const formData = new FormData();
formData.append('file', file);
await api.post('/upload', formData);

// Blob autom√°tico
await api.post('/image', blobData);</code></pre>
    </div>

    <div class="api-item">
      <h4>üõ°Ô∏è Type-Safety Nativo</h4>
      <p>
        Constru√≠do em TypeScript com tipos gen√©ricos para respostas tipadas e
        autocomplete completo.
      </p>
      <pre><code>interface User {
  id: number;
  name: string;
  email: string;
}

// TypeScript sabe que data √© User[]
const data = await api.get&lt;User[]&gt;('/users');
data[0].email; // ‚úÖ Autocomplete funciona</code></pre>
    </div>

    <div class="api-item">
      <h4>üé® API Limpa e Intuitiva</h4>
      <p>
        M√©todos HTTP sem√¢nticos (get, post, put, patch, delete) com assinatura
        consistente. Sem surpresas, sem complexidade desnecess√°ria.
      </p>
      <pre><code>const api = createApiClient({ baseURL: 'https://api.example.com' });

// GET
const users = await api.get('/users');

// POST
const newUser = await api.post('/users', { name: 'John' });

// PUT
const updated = await api.put('/users/1', { name: 'Jane' });

// PATCH
const patched = await api.patch('/users/1', { email: 'new@example.com' });

// DELETE
await api.delete('/users/1');</code></pre>
    </div>
  </div>

  <h3>Arquitetura</h3>
  <p>O Ease-Fetch opera em tr√™s camadas principais:</p>
  <ol>
    <li>
      <strong>Interceptors Layer:</strong> Processa requisi√ß√µes e respostas
      atrav√©s de uma cadeia de interceptors
    </li>
    <li>
      <strong>Retry Layer:</strong> Gerencia tentativas autom√°ticas com backoff
      exponencial para m√©todos idempotentes
    </li>
    <li>
      <strong>Transport Layer:</strong> Executa a requisi√ß√£o HTTP usando fetch
      nativo com timeout e AbortController
    </li>
  </ol>

  <div class="card">
    <p><strong>Fluxo de uma requisi√ß√£o:</strong></p>
    <pre><code>Request ‚Üí Request Interceptors ‚Üí Fetch + Timeout ‚Üí Retry (se necess√°rio)
  ‚Üí Response Interceptors ‚Üí Parse JSON ‚Üí Error Interceptors (se erro) ‚Üí Return</code></pre>
  </div>
</section>
